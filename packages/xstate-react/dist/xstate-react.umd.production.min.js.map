{"version":3,"file":"xstate-react.umd.production.min.js","sources":["../../../node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js","../src/useMachine.ts","../src/useConstant.ts","../src/useActor.ts","../src/utils.ts","../src/useService.ts"],"sourcesContent":["import { useLayoutEffect } from 'react';\n\nvar index =  useLayoutEffect ;\n\nexport default index;\n","import { useState, useEffect, useRef } from 'react';\nimport useIsomorphicLayoutEffect from 'use-isomorphic-layout-effect';\nimport {\n  interpret,\n  EventObject,\n  StateMachine,\n  State,\n  Interpreter,\n  InterpreterOptions,\n  MachineOptions,\n  StateConfig,\n  Typestate,\n  ActionObject,\n  ActionFunction,\n  ActionMeta,\n  StateNode\n} from 'xstate';\nimport { MaybeLazy } from './types';\nimport useConstant from './useConstant';\nimport { partition } from './utils';\n\nenum ReactEffectType {\n  Effect = 1,\n  LayoutEffect = 2\n}\n\nexport interface ReactActionFunction<TContext, TEvent extends EventObject> {\n  (\n    context: TContext,\n    event: TEvent,\n    meta: ActionMeta<TContext, TEvent>\n  ): () => void;\n  __effect: ReactEffectType;\n}\n\nexport interface ReactActionObject<TContext, TEvent extends EventObject>\n  extends ActionObject<TContext, TEvent> {\n  exec: ReactActionFunction<TContext, TEvent>;\n}\n\nfunction createReactActionFunction<TContext, TEvent extends EventObject>(\n  exec: ActionFunction<TContext, TEvent>,\n  tag: ReactEffectType\n): ReactActionFunction<TContext, TEvent> {\n  const effectExec: unknown = (...args: Parameters<typeof exec>) => {\n    // don't execute; just return\n    return () => {\n      return exec(...args);\n    };\n  };\n\n  Object.defineProperties(effectExec, {\n    name: { value: `effect:${exec.name}` },\n    __effect: { value: tag }\n  });\n\n  return effectExec as ReactActionFunction<TContext, TEvent>;\n}\n\nexport function asEffect<TContext, TEvent extends EventObject>(\n  exec: ActionFunction<TContext, TEvent>\n): ReactActionFunction<TContext, TEvent> {\n  return createReactActionFunction(exec, ReactEffectType.Effect);\n}\n\nexport function asLayoutEffect<TContext, TEvent extends EventObject>(\n  exec: ActionFunction<TContext, TEvent>\n): ReactActionFunction<TContext, TEvent> {\n  return createReactActionFunction(exec, ReactEffectType.LayoutEffect);\n}\n\nexport type ActionStateTuple<TContext, TEvent extends EventObject> = [\n  ReactActionObject<TContext, TEvent>,\n  State<TContext, TEvent>\n];\n\nfunction executeEffect<TContext, TEvent extends EventObject>(\n  action: ReactActionObject<TContext, TEvent>,\n  state: State<TContext, TEvent>\n): void {\n  const { exec } = action;\n  const originalExec = exec!(state.context, state._event.data, {\n    action,\n    state,\n    _event: state._event\n  });\n\n  originalExec();\n}\n\ninterface UseMachineOptions<TContext, TEvent extends EventObject> {\n  /**\n   * If provided, will be merged with machine's `context`.\n   */\n  context?: Partial<TContext>;\n  /**\n   * The state to rehydrate the machine to. The machine will\n   * start at this state instead of its `initialState`.\n   */\n  state?: StateConfig<TContext, TEvent>;\n}\n\nexport function useMachine<\n  TContext,\n  TEvent extends EventObject,\n  TTypestate extends Typestate<TContext> = { value: any; context: TContext }\n>(\n  getMachine: MaybeLazy<StateMachine<TContext, any, TEvent, TTypestate>>,\n  options: Partial<InterpreterOptions> &\n    Partial<UseMachineOptions<TContext, TEvent>> &\n    Partial<MachineOptions<TContext, TEvent>> = {}\n): [\n  State<TContext, TEvent, any, TTypestate>,\n  Interpreter<TContext, any, TEvent, TTypestate>['send'],\n  Interpreter<TContext, any, TEvent, TTypestate>\n] {\n  const machine = useConstant(() => {\n    return typeof getMachine === 'function' ? getMachine() : getMachine;\n  });\n\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    typeof getMachine !== 'function'\n  ) {\n    const [initialMachine] = useState(machine);\n\n    if (machine !== initialMachine) {\n      console.warn(\n        'Machine given to `useMachine` has changed between renders. This is not supported and might lead to unexpected results.\\n' +\n          'Please make sure that you pass the same Machine as argument each time.'\n      );\n    }\n  }\n\n  const {\n    context,\n    guards,\n    actions,\n    activities,\n    services,\n    delays,\n    state: rehydratedState,\n    ...interpreterOptions\n  } = options;\n\n  const [resolvedMachine, service] = useConstant<\n    [\n      StateNode<TContext, any, TEvent, TTypestate>,\n      Interpreter<TContext, any, TEvent, TTypestate>\n    ]\n  >(() => {\n    const machineConfig = {\n      context,\n      guards,\n      actions,\n      activities,\n      services,\n      delays\n    };\n    const machineWithConfig = machine.withConfig(machineConfig, {\n      ...machine.context,\n      ...context\n    } as TContext);\n\n    return [\n      machineWithConfig,\n      interpret(machineWithConfig, { deferEvents: true, ...interpreterOptions })\n    ];\n  });\n\n  const [state, setState] = useState<State<TContext, TEvent, any, TTypestate>>(\n    () => {\n      // Always read the initial state to properly initialize the machine\n      // https://github.com/davidkpiano/xstate/issues/1334\n      const { initialState } = resolvedMachine;\n      return rehydratedState ? State.create(rehydratedState) : initialState;\n    }\n  );\n\n  const effectActionsRef = useRef<\n    Array<[ReactActionObject<TContext, TEvent>, State<TContext, TEvent>]>\n  >([]);\n  const layoutEffectActionsRef = useRef<\n    Array<[ReactActionObject<TContext, TEvent>, State<TContext, TEvent>]>\n  >([]);\n\n  useIsomorphicLayoutEffect(() => {\n    service\n      .onTransition((currentState) => {\n        // Only change the current state if:\n        // - the incoming state is the \"live\" initial state (since it might have new actors)\n        // - OR the incoming state actually changed.\n        //\n        // The \"live\" initial state will have .changed === undefined.\n        const initialStateChanged =\n          currentState.changed === undefined &&\n          Object.keys(currentState.children).length;\n\n        if (currentState.changed || initialStateChanged) {\n          setState(currentState);\n        }\n\n        if (currentState.actions.length) {\n          const reactEffectActions = currentState.actions.filter(\n            (action): action is ReactActionObject<TContext, TEvent> => {\n              return (\n                typeof action.exec === 'function' &&\n                '__effect' in\n                  (action as ReactActionObject<TContext, TEvent>).exec\n              );\n            }\n          );\n\n          const [effectActions, layoutEffectActions] = partition(\n            reactEffectActions,\n            (action): action is ReactActionObject<TContext, TEvent> => {\n              return action.exec.__effect === ReactEffectType.Effect;\n            }\n          );\n\n          effectActionsRef.current.push(\n            ...effectActions.map<ActionStateTuple<TContext, TEvent>>(\n              (effectAction) => [effectAction, currentState]\n            )\n          );\n\n          layoutEffectActionsRef.current.push(\n            ...layoutEffectActions.map<ActionStateTuple<TContext, TEvent>>(\n              (layoutEffectAction) => [layoutEffectAction, currentState]\n            )\n          );\n        }\n      })\n      .start(rehydratedState ? State.create(rehydratedState) : undefined);\n\n    return () => {\n      service.stop();\n    };\n  }, []);\n\n  // Make sure actions and services are kept updated when they change.\n  // This mutation assignment is safe because the service instance is only used\n  // in one place -- this hook's caller.\n  useEffect(() => {\n    Object.assign(service.machine.options.actions, actions);\n  }, [actions]);\n\n  useEffect(() => {\n    Object.assign(service.machine.options.services, services);\n  }, [services]);\n\n  // this is somewhat weird - this should always be flushed within useLayoutEffect\n  // but we don't want to receive warnings about useLayoutEffect being used on the server\n  // so we have to use `useIsomorphicLayoutEffect` to silence those warnings\n  useIsomorphicLayoutEffect(() => {\n    while (layoutEffectActionsRef.current.length) {\n      const [\n        layoutEffectAction,\n        effectState\n      ] = layoutEffectActionsRef.current.shift()!;\n\n      executeEffect(layoutEffectAction, effectState);\n    }\n  }, [state]); // https://github.com/davidkpiano/xstate/pull/1202#discussion_r429677773\n\n  useEffect(() => {\n    while (effectActionsRef.current.length) {\n      const [effectAction, effectState] = effectActionsRef.current.shift()!;\n\n      executeEffect(effectAction, effectState);\n    }\n  }, [state]);\n\n  return [state, service.send, service];\n}\n","import * as React from 'react';\n\ninterface ResultBox<T> {\n  v: T;\n}\n\nexport default function useConstant<T>(fn: () => T): T {\n  const ref = React.useRef<ResultBox<T>>();\n\n  if (!ref.current) {\n    ref.current = { v: fn() };\n  }\n\n  return ref.current.v;\n}\n","import { useState, useRef } from 'react';\nimport useIsomorphicLayoutEffect from 'use-isomorphic-layout-effect';\nimport { Sender, ActorRefLike } from './types';\nimport { EventObject, Actor } from 'xstate';\nimport useConstant from './useConstant';\n\nexport function useActor<TEvent extends EventObject, TEmitted = any>(\n  actorRef: ActorRefLike<TEvent, TEmitted> | Actor,\n  getSnapshot: (actor: typeof actorRef) => TEmitted = (a) =>\n    'state' in a ? a.state : (undefined as any)\n): [TEmitted, Sender<TEvent>] {\n  const actorRefRef = useRef(actorRef);\n  const deferredEventsRef = useRef<TEvent[]>([]);\n  const [current, setCurrent] = useState(() => getSnapshot(actorRef));\n\n  const send: Sender<TEvent> = useConstant(() => (event) => {\n    const currentActorRef = actorRefRef.current;\n    // If the previous actor is a deferred actor,\n    // queue the events so that they can be replayed\n    // on the non-deferred actor.\n    if ('deferred' in currentActorRef && currentActorRef.deferred) {\n      deferredEventsRef.current.push(event);\n    } else {\n      currentActorRef.send(event);\n    }\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    actorRefRef.current = actorRef;\n    setCurrent(getSnapshot(actorRef));\n    const subscription = actorRef.subscribe(setCurrent);\n\n    // Dequeue deferred events from the previous deferred actorRef\n    while (deferredEventsRef.current.length > 0) {\n      const deferredEvent = deferredEventsRef.current.shift()!;\n\n      actorRef.send(deferredEvent);\n    }\n\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [actorRef]);\n\n  return [current, send];\n}\n","export function partition<T, A extends T, B extends T>(\n  items: T[],\n  predicate: (item: T) => item is A\n): [A[], B[]] {\n  const [truthy, falsy] = [[], []] as [A[], B[]];\n\n  for (const item of items) {\n    if (predicate(item)) {\n      truthy.push(item);\n    } else {\n      falsy.push(item as B);\n    }\n  }\n\n  return [truthy, falsy];\n}\n","import { useMemo } from 'react';\nimport { EventObject, State, Interpreter, Typestate } from 'xstate';\nimport { useActor } from './useActor';\nimport { ActorRef, PayloadSender } from './types';\n\nexport function fromService<TContext, TEvent extends EventObject>(\n  service: Interpreter<TContext, any, TEvent>\n): ActorRef<TEvent, State<TContext, TEvent>> {\n  if (process.env.NODE_ENV !== 'production' && !('machine' in service)) {\n    throw new Error(\n      `Attempted to use an actor-like object instead of a service in the useService() hook. Please use the useActor() hook instead.`\n    );\n  }\n\n  const { machine } = service as Interpreter<TContext, any, TEvent>;\n  return {\n    send: service.send.bind(service),\n    subscribe: (cb) => service.subscribe((state) => cb(state)),\n    stop: service.stop!,\n    // TODO: remove compat lines in a new major, replace literal number with InterpreterStatus then as well\n    current:\n      ('status' in service ? service.status : (service as any)._status) !== 0\n        ? service.state\n        : machine.initialState,\n    name: service.sessionId\n  };\n}\n\nexport function useService<\n  TContext,\n  TEvent extends EventObject,\n  TTypestate extends Typestate<TContext> = { value: any; context: TContext }\n>(\n  service: Interpreter<TContext, any, TEvent, TTypestate>\n): [State<TContext, TEvent, any, TTypestate>, PayloadSender<TEvent>] {\n  const serviceActor = useMemo(() => fromService(service), [service]);\n\n  const [state] = useActor<TEvent, State<TContext, TEvent, any, TTypestate>>(\n    serviceActor,\n    (actor) => (actor as typeof serviceActor).current\n  );\n\n  return [state, service.send];\n}\n"],"names":["ReactEffectType","index","useLayoutEffect","useConstant","fn","ref","React","current","v","createReactActionFunction","exec","tag","effectExec","args","Object","defineProperties","name","value","__effect","executeEffect","action","state","context","_event","data","originalExec","useActor","actorRef","getSnapshot","a","undefined","actorRefRef","useRef","deferredEventsRef","useState","setCurrent","send","event","currentActorRef","deferred","push","useIsomorphicLayoutEffect","subscription","subscribe","length","deferredEvent","shift","unsubscribe","Effect","LayoutEffect","getMachine","options","machine","guards","actions","activities","services","delays","rehydratedState","interpreterOptions","machineWithConfig","withConfig","interpret","deferEvents","resolvedMachine","service","initialState","State","create","setState","effectActionsRef","layoutEffectActionsRef","onTransition","currentState","initialStateChanged","changed","keys","children","items","predicate","truthy","falsy","item","partition","filter","layoutEffectActions","map","effectAction","layoutEffectAction","start","stop","useEffect","assign","useMemo","bind","cb","status","_status","sessionId","fromService","actor"],"mappings":"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"}